\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{amsmath}
\usepackage{amssymb}

\title{Cost Model Formulas for Distributed NoSQL Databases}
\author{ARROUET--LE BRIGNONEN Aubin, BAUZIN Jérémy et AUPERIN Hugo}
\date{}

\begin{document}
\maketitle

\section{Query Size (Input \& Output)}

In this course, the size of a query is modeled as the size of the JSON-like object
sent to the servers. It includes:
\begin{itemize}
    \item Filter fields (key + value),
    \item Projected fields (key + boolean/int),
    \item A key overhead of $12$ bytes per key,
    \item An additional $12$ bytes for each nested object level.
\end{itemize}

\subsection{Value Sizes}
\[
\text{int/boolean} = 8\text{ B}, \quad
\text{string} = 80\text{ B}, \quad
\text{date} = 20\text{ B}, \quad
\text{key overhead} = 12\text{ B}
\]

\subsection{Query Input Size}
If the query contains $k$ fields with values $v_i$:
\[
\text{size}_{input}
=
\sum_{i=1}^{k}
\left(
12 + \text{size}(v_i)
\right)
+ 12 \cdot (\text{nesting levels})
\]

\subsection{Query Output Size}
If each output document contains $m$ fields:
\[
\text{size}_{msg}
=
\sum_{j=1}^{m}
\left(12 + \text{size}(value_j)\right)
\]

Total output volume:
\[
\text{vol}_{output}(q) = res_q \cdot \text{size}_{msg}
\]

\subsection{Example: Query Q1}

Consider the query:
\[
\texttt{SELECT S.quantity, S.location FROM Stock S WHERE S.IDP = \$IDP \text{ AND } S.IDW = \$IDW;}
\]

We assume the following:
\begin{itemize}
    \item \texttt{IDP} is an integer ($8$ B),
    \item \texttt{IDW} is an integer ($8$ B),
    \item \texttt{quantity} is projected and modeled as a boolean/int ($8$ B),
    \item \texttt{location} is projected and modeled as a boolean/int ($8$ B),
    \item Each field contributes a key overhead of $12$ B,
    \item The query is wrapped in a \texttt{Stock} object, adding one extra key of $12$ B.
\end{itemize}

\subsubsection*{Input Size Calculation}

Value sizes:
\[
8 + 8 + 8 + 8 = 32\text{ B}
\]

Key sizes:
\[
4 \times 12 = 48\text{ B}
\]

Nesting overhead:
\[
12\text{ B}
\]

Total input size:
\[
\text{size}_{input}
= 32 + 48 + 12
= 92\text{ B}
\]

\subsubsection*{Output Message Size}

Fields returned:
\begin{itemize}
    \item \texttt{quantity}: $12 + 8$ B,
    \item \texttt{location}: $12 + 8$ B.
\end{itemize}

Thus:
\[
\text{size}_{msg}
= (12 + 8) + (12 + 8)
= 40\text{ B}
\]

Total output volume for $res_q$ results:
\[
\text{vol}_{output}(q) = res_q \cdot 40\text{ B}
\]

\section{Time Cost}

Total execution time:
\[
\text{time}_{DB}
=
\sum_{q=1}^Q
\left(
\frac{\text{vol}_{network}(q)}{\text{bandwidth}_{network}}
+
\frac{\text{vol}_{RAM}(q)}{\text{bandwidth}_{RAM}}
\right)
\times freq(q)
\]

\subsection{Network Volume}

\paragraph{Filter queries}
\[
\text{vol}_{network}(q)
=
S \cdot \text{size}_{input}
+
res_q \cdot \text{size}_{msg}
\]

\paragraph{Aggregate queries}
\[
\text{vol}_{network}(q)
=
S \cdot \text{size}_{input}
+
shuffle \cdot \text{size}_{msg}
+
res_q \cdot \text{size}_{msg}
\]

\subsection{RAM Volume}

Per server:
\[
\text{vol}_{RAM}(q,n)
=
index_q
+
sel_{att} \cdot coll_{q,n} \cdot size_{doc}(q)
\]

Global:
\[
\text{vol}_{RAM}(q)
=
\max_n \left(\text{vol}_{RAM}(q,n)\right)
\]

\section{Environmental Cost}

\subsection{Carbon from Network}
\[
impact_{network}(q)
=
\text{vol}_{network}(q) \cdot CO2_{network}
\]

\subsection{Carbon from RAM}
\[
impact_{RAM}(q)
=
\text{vol}_{RAM}(q) \cdot CO2_{RAM}
\]

\subsection{Total Carbon Footprint}
\[
impact(DB)
=
\sum_{q=1}^Q
\left(
impact_{network}(q)
+
impact_{RAM}(q)
\right)
\times freq(q)
\]

\section{Financial Cost}

\subsection{Monthly Price}
\[
price_{DB}
=
price_s \cdot 
\max\left(
\frac{vol_{DB} \cdot 3}{capacity_{storage}},
\frac{vol_{DB}}{capacity_{RAM}} \cdot 2
\right)
+
externalFees
\cdot
\sum_{q=1}^{Q}
vol_{external}(q)\cdot freq(q)
\]

\section{Sharding and Indexing Strategy}

\subsection{Sharding}

\[
S =
\begin{cases}
1 & \text{if filtered on the sharding key} \\
\#shards & \text{otherwise}
\end{cases}
\]

\subsection{When to Use Sharding}
\begin{itemize}
    \item Dataset too large for one server.
    \item Queries often filter on the sharding key.
\end{itemize}

\subsection{When to Avoid Sharding}
\begin{itemize}
    \item Queries mostly filter on non-sharding attributes.
    \item Aggregations require scanning all shards.
\end{itemize}

\section{Algorithm Choice}

\subsection{Index Lookup}
\[
\text{vol}_{RAM}(q)
=
index_q + sel_{att} \cdot coll \cdot size_{doc}
\]

where $index_q \approx 1$ MB.

\subsection{Full Scan}
Used when no index exists or when selectivity is high:
\[
sel_{att} = 1
\]

\end{document}